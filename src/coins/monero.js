'use strict'

const BigNum = require('bignum')
const Crypto = require('crypto')
const CryptoNoteUtil = require('cryptonote-util')
const CryptoNight = require('node-cryptonight').async

const AbstractCoin = require('./abstract-coin')

const INSTANCE_ID = Crypto.randomBytes(4)

const TRANSACTION_FEE = 0.11 // configurable
const TRANSACTION_FEE_LIMIT = 4
const PAYMENT_THRESHOLD = 1

class Monero extends AbstractCoin {
  constructor ({ address }, daemon, wallet) {
    super()
    this.address = address // pool address
    this.daemon = daemon
    this.wallet = wallet
    this.significantDigits = 1000000000000
    this.code = 'XMR'
    this.name = 'monero'
    this.transactionFee = TRANSACTION_FEE * this.significantDigits
  }

  transfer (options) {
    return this.wallet.transfer(options)
  }

  getMaxmimumDestinationsPerTransaction () {
    return 120
  }

  getPaymentThreshold () {
    return PAYMENT_THRESHOLD
  }

  getTransactionFee (amount) {
    if (amount <= PAYMENT_THRESHOLD) {
      return this.transactionFee
    } else if (amount <= TRANSACTION_FEE_LIMIT) {
      let x = this.transactionFee / (TRANSACTION_FEE_LIMIT - PAYMENT_THRESHOLD)
      return this.transactionFee - ((amount - PAYMENT_THRESHOLD) * x)
    } else {
      return 0
    }
  }

  fromAtomicUnits (amount) {
    return amount / this.significantDigits
  }

  toAtomicUnits (amount) {
    return amount * this.significantDigits
  }

  /**
   * @return {BigNum} the base difficulty
   */
  getBaseDifficulty () {
    return new BigNum('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 16)
  }

  async getBlockHeaderByHeight (height) {
    return this.daemon.getBlockHeader(height)
      .then(blockHeader => new BlockHeader(blockHeader))
  }

  async getBlockHeaderByHash (hash) {
    return this.daemon.getBlockHeader(hash)
      .then(blockHeader => new BlockHeader(blockHeader))
  }

  /**
   * Fetches the most recent block header form the monero daemon
   *
   * @returns {Promise.<BlockHeader>} block template
   */
  _getLastBlockHeader () {
    return this.daemon.getLastBlockHeader()
      .then(blockHeader => new BlockHeader(blockHeader))
  }

  /**
   * Fetches the most recent block template form the monero daemon
   *
   * @returns {Promise.<BlockTemplate>} block template
   */
  _getBlockTemplate () {
    return this.daemon.getBlockTemplate(this.address, 17)
      .then(blockTemplate => new BlockTemplate(blockTemplate))
  }

  /**
   * Submits a block to the Monero dameon
   *
   * @param {Block} block to be submitted to the daemon
   */
  submit (block) {
    return new Promise((resolve, reject) => {
      this.daemon.client
        .request('submitblock', { blob: block.blob.toString('hex') }, (err, response) => {
          if (err) return reject(err)
          if (response.error) return reject(response.error.message)
          return resolve(response.result)
        })
    })
  }
}

class BlockTemplate {
  constructor (blockTemplate) {
    this._blockTemplate = blockTemplate

    this.height = blockTemplate.height
    this.difficulty = blockTemplate.difficulty
    this.reservedOffset = blockTemplate.offset
    this.previousHash = blockTemplate.previous
    this.blockTemplateHex = blockTemplate.blob
    Object.freeze(this)
  }

  /**
   * Generates a block hashing blob that will be submitted to the miner
   *
   * @param {Number} extra_nonce unique number per job
   * @returns {Buffer} block hashing blob
   */
  getBlockHashingBlob (extra_nonce) { // eslint-disable-line camelcase
    const blockTemplateBlob = Buffer.from(this.blockTemplateHex, 'hex')
    // Copy the instance identifier to the reserved offset + 4 bytes. Copy in 4 bytes.
    INSTANCE_ID.copy(blockTemplateBlob, this.reservedOffset + 4, 0, 3)
    blockTemplateBlob.writeUInt32BE(extra_nonce, this.reservedOffset)
    return CryptoNoteUtil.convert_blob(blockTemplateBlob)
  }

  /**
   * Generates a block blob that can be submitted to the monero daemon
   *
   * @param {Buffer} nonce generated by the mining process
   * @param {Number} extra_nonce generated by the pool before generating the block hashing blob
   * @param {Buffer} hash optional pre calculated hash for the block
   * @returns {Promise.<Block>} block
   */
  getBlock (nonce, extra_nonce, hash) { // eslint-disable-line camelcase
    const blockTemplateBlob = Buffer.from(this.blockTemplateHex, 'hex')
    blockTemplateBlob.writeUInt32BE(extra_nonce, this.reservedOffset)
    // Copy the instance identifier to the reserved offset + 4 bytes. Copy in 4 bytes.
    INSTANCE_ID.copy(blockTemplateBlob, this.reservedOffset + 4, 0, 3)
    const blockBlob = CryptoNoteUtil.construct_block_blob(blockTemplateBlob, nonce)
    return Promise.resolve(new Block(blockBlob, this.height, this.difficulty, hash))
  }
}

class BlockHeader {
  constructor (blockHeader) {
    this._blockHeader = blockHeader
    this.height = blockHeader.height
    this.reward = blockHeader.reward
    this.difficulty = blockHeader.difficulty
  }
}

class Block {
  constructor (blockBlob, height, difficulty, hash) {
    this._blockBlob = blockBlob
    this._hash = hash
    this.height = height
    this.difficulty = difficulty
    this.locked = true
  }

  /**
   * The block
   *
   * @returns {Buffer} blob
   */
  get blob () {
    return this._blockBlob
  }

  /**
   * Returns the identifer of the block.
   * The identifier of a block is the result of hashing the following data with Keccak:
   *  * size of [ block_header, merkle root hash, and number of transactions ] in bytes
   *  * block_header
   *  * merkle root hash
   *  * number of transactions
   *
   * @returns {Number} identifier
   */
  get id () {
    return CryptoNoteUtil.get_block_id(this._blockBlob)
  }

  /**
   * Calculates the hash of the block
   *
   * @returns {Promise.<Buffer>} block hash
   */
  get hash () {
    if (this._hash) {
      return this._hash
    }
    const convertedBlob = CryptoNoteUtil.convert_blob(this._blockBlob)
    this.hash = new Promise((resolve, reject) => CryptoNight(convertedBlob, (hash) => resolve(hash)))
    return this.hash
  }

  /**
   * It validates that the block matches the given hash.
   * A succesful promise containing the block is returned in that case.
   * Otherwise the promise is rejected
   *
   * @param {Buffer} hash hash to compare to
   * @returns {Promise.<Block>} block
   */
  checkHashMatches (hash) {
    return this.hash.then(h => h.equals(hash)
      ? this
      : Promise.reject(new Error('Invalid hash'))
    )
  }

  toJSON () {
    return {
      hash: this.hash.toString('hex'),
      height: this.height,
      difficulty: this.difficulty,
      locked: this.locked
    }
  }
}

module.exports = Monero
