'use strict'

const BigNum = require('bignum')
const Crypto = require('crypto')
const CryptoNoteUtil = require('cryptonote-util')
const CryptoNight = require('node-cryptonight').async

const AbstractCoin = require('./abstract-coin')

const INSTANCE_ID = Crypto.randomBytes(4)

class Monero extends AbstractCoin {
  constructor (address, daemonRpc) {
    super()
    this.address = address // pool address
    this.daemon = daemonRpc
    this.significantDigits = 1000000000000
    this.code = 'XMR'
  }

  /**
   * @return {BigNum} the base difficulty
   */
  getBaseDifficulty () {
    return new BigNum('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 16)
  }

  /**
   * Fetches the most recent block template form the monero daemon
   *
   * @returns {Promise.<BlockTemplate>} block template
   */
  _getBlockTemplate () {
    return this.daemon
      .request('getblocktemplate', { reserve_size: 17, wallet_address: this.address })
      .then(response => {
        if (response.error) {
          throw new Error(response.error.message)
        }
        return response.result
      })
      .then(blockTemplate => new BlockTemplate(blockTemplate))
  }

  getBlockHeaderByHeight (height) {
    return this.daemon
      .request('getblockheaderbyheight', { height })
      .then(response => {
        if (response.error) {
          throw new Error(response.error.message)
        }
        return response.result.block_header
      })
      .then(blockHeader => new BlockHeader(blockHeader))
  }

  getBlockHeaderByHash (hash) {
    return this.daemon
      .request('getblockheaderbyhash', { hash })
      .then(response => {
        if (response.error) {
          throw new Error(response.error.message)
        }
        return response.result.block_header
      })
      .then(blockHeader => new BlockHeader(blockHeader))
  }

  _getLastBlockHeader () {
    return this.daemon
      .request('getlastblockheader')
      .then(response => {
        if (response.error) {
          throw new Error(response.error.message)
        }
        return response.result.block_header
      })
      .then(blockHeader => new BlockHeader(blockHeader))
  }

  /**
   * Submits a block to the Monero dameon
   *
   * @param {Block} block to be submitted to the daemon
   */
  submit (block) {
    return this.daemon
      .request('submitblock', [block.blob.toString('hex')])
      .then(response => {
        if (response.error) {
          throw new Error(response.error.message)
        }
        return response.result
      })
  }
}

class BlockTemplate {
  constructor (blockTemplate) {
    this._blockTemplate = blockTemplate

    this.height = blockTemplate.height
    this.difficulty = blockTemplate.difficulty
    this.reservedOffset = blockTemplate.reserved_offset
    this.previousHash = blockTemplate.previous_hash
    this.blockTemplateHex = blockTemplate.blocktemplate_blob
    this.blockHashingHex = blockTemplate.blockhashing_blob // unused
    Object.freeze(this)
  }

  /**
   * Generates a block hashing blob that will be submitted to the miner
   *
   * @param {Number} extra_nonce unique number per job
   * @returns {Buffer} block hashing blob
   */
  getBlockHashingBlob (extra_nonce) { // eslint-disable-line camelcase
    const blockTemplateBlob = Buffer.from(this.blockTemplateHex, 'hex')
    // Copy the instance identifier to the reserved offset + 4 bytes. Copy in 4 bytes.
    INSTANCE_ID.copy(blockTemplateBlob, this.reservedOffset + 4, 0, 3)
    blockTemplateBlob.writeUInt32BE(extra_nonce, this.reservedOffset)
    return CryptoNoteUtil.convert_blob(blockTemplateBlob)
  }

  /**
   * Generates a block blob that can be submitted to the monero daemon
   *
   * @param {Buffer} nonce generated by the mining process
   * @param {Number} extra_nonce generated by the pool before generating the block hashing blob
   * @param {Buffer} hash optional pre calculated hash for the block
   * @returns {Promise.<Block>} block
   */
  getBlock (nonce, extra_nonce, hash) { // eslint-disable-line camelcase
    const blockTemplateBlob = Buffer.from(this.blockTemplateHex, 'hex')
    blockTemplateBlob.writeUInt32BE(extra_nonce, this.reservedOffset)
    // Copy the instance identifier to the reserved offset + 4 bytes. Copy in 4 bytes.
    INSTANCE_ID.copy(blockTemplateBlob, this.reservedOffset + 4, 0, 3)
    const blockBlob = CryptoNoteUtil.construct_block_blob(blockTemplateBlob, nonce)
    return Promise.resolve(new Block(blockBlob, this.height, this.difficulty, hash))
  }
}

class BlockHeader {
  constructor (blockHeader) {
    this._blockHeader = blockHeader
    this.height = blockHeader.height
    this.reward = blockHeader.reward
    this.difficulty = blockHeader.difficulty
  }
}

class Block {
  constructor (blockBlob, height, difficulty, hash) {
    this._blockBlob = blockBlob
    this._hash = hash
    this.height = height
    this.difficulty = difficulty
    this.locked = true
  }

  /**
   * The block
   *
   * @returns {Buffer} blob
   */
  get blob () {
    return this._blockBlob
  }

  /**
   * Returns the identifer of the block.
   * The identifier of a block is the result of hashing the following data with Keccak:
   *  * size of [ block_header, merkle root hash, and number of transactions ] in bytes
   *  * block_header
   *  * merkle root hash
   *  * number of transactions
   *
   * @returns {Number} identifier
   */
  get id () {
    return CryptoNoteUtil.get_block_id(this._blockBlob)
  }

  /**
   * Calculates the hash of the block
   *
   * @returns {Promise.<Buffer>} block hash
   */
  get hash () {
    if (this._hash) {
      return this._hash
    }
    const convertedBlob = CryptoNoteUtil.convert_blob(this._blockBlob)
    this.hash = new Promise((resolve, reject) => CryptoNight(convertedBlob, (hash) => resolve(hash)))
    return this.hash
  }

  /**
   * It validates that the block matches the given hash.
   * A succesful promise containing the block is returned in that case.
   * Otherwise the promise is rejected
   *
   * @param {Buffer} hash hash to compare to
   * @returns {Promise.<Block>} block
   */
  checkHashMatches (hash) {
    return this.hash.then(h => h.equals(hash)
      ? this
      : Promise.reject(new Error('Invalid hash'))
    )
  }

  toJSON () {
    return {
      hash: this.hash.toString('hex'),
      height: this.height,
      difficulty: this.difficulty,
      locked: this.locked
    }
  }
}

module.exports = Monero
