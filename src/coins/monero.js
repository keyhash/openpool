'use strict'

const BigNum = require('bignum')
const Crypto = require('crypto')
const CryptoNoteUtil = require('cryptonote-util')
const CryptoNight = require('node-cryptonight').hash

const Coin = require('./abstract-coin')

const INSTANCE_ID = Crypto.randomBytes(4)

class Monero extends Coin {
  constructor (address, daemonRpc) {
    super()
    this.address = address // pool address
    this.daemon = daemonRpc
  }

  /**
   * @return {BigNum} the base difficulty
   */
  getBaseDifficulty () {
    return new BigNum('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 16)
  }

  /**
   * Fetches the most recent block template form the monero daemon
   *
   * @returns {BlockTemplate} block template
   */
  _getBlockTemplate () {
    return this.daemon
      .request('getblocktemplate', { reserve_size: 17, wallet_address: this.address })
      .then(response => {
        if (response.error) {
          throw new Error(response.error.message)
        }
        return response.result
      })
      .then(blockTemplate => new BlockTemplate(blockTemplate))
  }

  submit (block) {
    return this.daemon
      .request('submitblock', [block.toString('hex')])
      .then(response => {
        if (response.error) {
          throw new Error(response.error.message)
        }
        return response.result
      })
  }
}

class BlockTemplate {
  constructor (blockTemplate) {
    this._blockTemplate = blockTemplate

    this.height = blockTemplate.height
    this.difficulty = blockTemplate.difficulty
    this.reservedOffset = blockTemplate.reserved_offset
    this.previousHash = blockTemplate.previous_hash
    this.blockTemplateHex = blockTemplate.blocktemplate_blob
    // this.blockHashingHex = this.blockTemplate.blockhashing_blob
  }

  /**
   * Generates a block hashing blob that will be submitted to the miner
   *
   * @param {Number} extraNonce unique number per job
   * @returns {Buffer} block hashing blob
   */
  getBlockHashingBlob (extraNonce) {
    const blockTemplateBlob = Buffer.from(this.blockTemplateHex, 'hex')
    // Copy the instance identifier to the reserved offset + 4 bytes. Copy in 4 bytes.
    INSTANCE_ID.copy(blockTemplateBlob, this.reservedOffset + 4, 0, 3)
    blockTemplateBlob.writeUInt32BE(extraNonce, this.reservedOffset)
    return CryptoNoteUtil.convert_blob(blockTemplateBlob)
  }

  /**
   * Generates a block blob that can be submitted to the monero daemon
   *
   * @param {Buffer} nonce generated by the mining process
   * @param {Number} extraNonce generated by the pool before generating the block hashing blob
   * @returns {Block} block
   */
  getBlockBlob (nonce, extraNonce) {
    const blockTemplateBlob = Buffer.from(this.blockTemplateHex, 'hex')
    blockTemplateBlob.writeUInt32BE(extraNonce, this.reservedOffset)
    // Copy the instance identifier to the reserved offset + 4 bytes. Copy in 4 bytes.
    INSTANCE_ID.copy(blockTemplateBlob, this.reservedOffset + 4, 0, 3)
    const blockBlob = CryptoNoteUtil.construct_block_blob(blockTemplateBlob, nonce)
    return new Block(blockBlob)
  }
}

class Block {
  constructor (blockBlob) {
    this._blockBlob = blockBlob
  }

  /**
   * @returns {Buffer} blob
   */
  get blob () {
    return this._blockBlob
  }

  /**
   * The identifier of a block is the result of hashing the following data with Keccak:
   *  * size of [ block_header, merkle root hash, and number of transactions ] in bytes
   *  * block_header
   *  * merkle root hash
   *  * number of transactions
   * @returns {Number} block id
   */
  get id () {
    return CryptoNoteUtil.get_block_id(this._blockBlob)
  }

  /**
   * Returns the hash of the block
   */
  get hash () {
    const convertedBlob = CryptoNoteUtil.convert_blob(this._blockBlob)
    if (this._hash) {
      return this.hash
    }
    this.hash = CryptoNight(convertedBlob) // @todo promise
    return this.hash
  }
}

module.exports = Monero
